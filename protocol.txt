数据按照高位在前的方式。
例如：
0x1234
在包中的位置为：0x12,0x34

//CRC校验算法
uint16_t crc16_calculate(const uint8_t *data, uint16_t length)
{
    uint16_t crc, i;
    crc = 0;
    while(length--)
    {
        crc = crc ^ (uint16_t) *data++ << 8;
        for(i = 0; i < 8; i++)
        {
            if(crc & 0x8000)
                crc = crc << 1 ^ 0x1021;
            else
                crc = crc << 1;
        }
    }
    return (crc & 0xFFFF);
}
C代表android
S代表嵌入式
C(S)端主动发起命令时，命令后紧跟0x00,标示这是一个主动发送的信息，对端响应该结果，
S(C)端收到命令后，需要立刻响应该命令，返回一个消息给对端；消息包含该命令以及一个0x03的值，表明我收到你的请求了
    然后根据执行结果返回该命令的最后执行结果
例如：
停止打水成功的交互流程：
    C->S:发送 0x03 0x00
    S->C:发送 0x03 0x03
    S->C:发送 0x03 0x02
停止打水失败的交互流程：
    C->S:发送 0x03 0x00
    S->C:发送 0x03 0x03
    S->C:发送 0x03 0x01

数据信息中的指令：
0xFF 心跳
0x01 打水 
        7e 01 01 05 01 00 01 00 10 e3 33 7e
        0x01(结果1Byte，0x00(C发送制作请求),0x01(S发送请求失败),0x02(S发送制作成功完成)，0x03(S发送制作开始并在进行中))
        0x01(0x01(热水),0x02(冷水))，
        0xFFFF(制作的数量,当值为FFFF持续制作),
0x03 停止打水
        7e 01 01 02 03 00 d6 e7 7e
        0x01(结果1Byte，0x00(C发送请求),0x01(S返回失败),0x02(S返回成功)，0x03(S发送开始并在进行中))
0x02 校准
        0x01(结果1Byte，0x00(C发送请求),0x01(S返回失败),0x02(S返回成功)，0x03(S发送开始并在进行中))
        0x01(0x01(启动校准),0x02(输入校准结果))
        0x01(0x01(热水),0x02(冷水))
        0xFFFF(校准打出的水量)
0x04 故障报警 0xE1(0xE2,0xE3)
        0x01(结果1Byte，0x00(S发送请求),0x01(C返回失败),0x02(C返回成功)，0x03(C发送开始并在进行中))
0x05 设置温度
        0x01(结果1Byte，0x00(C发送请求),0x01(S返回失败),0x02(S返回成功)，0x03(S发送开始并在进行中))
        温度信息
0x06 设置时间
        0x01(结果1Byte，0x00(C发送请求),0x01(S返回失败),0x02(S返回成功)，0x03(S发送开始并在进行中))
        时间信息
0x07 设置开机关机时间
        0x01(结果1Byte，0x00(C发送请求),0x01(S返回失败),0x02(S返回成功)，0x03(S发送开始并在进行中))
        0x01(0x01 开机时间,0x02 关机时间)
        时间信息
0x09 热水机状态信息（嵌入式发送时返回热水机状态，android发送时表情请求当前热水机状态）状态信息（嵌入式模块根据设备信息返回）
        0x01(结果1Byte，0x00(C发送请求),0x01(S返回失败),0x02(S返回成功)，0x03(S发送开始执行并在进行中))
        0x01(0x01(可以打冷水),0x02(可以打热水),0x03(可以打水))

*****************
11/08 更新：因为java不支持无符号整数，因此目前数据通道类型暂不支持0x04



